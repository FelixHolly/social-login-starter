package at.holly.socialloginstarter.service;

import at.holly.socialloginstarter.model.User;
import at.holly.socialloginstarter.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service for managing user data and business logic with JPA persistence.
 *
 * This demonstrates understanding of:
 * 1. Spring Data JPA repository integration
 * 2. Transaction management with @Transactional
 * 3. The "find or create" pattern for OAuth2 user processing
 * 4. Proper separation of concerns (Service vs Repository layer)
 */
@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    private final UserRepository userRepository;

    /**
     * Constructor injection of UserRepository
     * (Preferred over field injection for testability)
     */
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * Processes a user login from an OAuth2 provider.
     * Implements the "find or create" pattern typical in OAuth2 implementations.
     *
     * Transaction management:
     * - @Transactional ensures this operation is atomic
     * - If user exists, updates are persisted
     * - If new user, creation is persisted
     * - On error, transaction rolls back
     *
     * @param user The user from the OAuth2 provider
     * @return The processed user (either newly created or updated existing user)
     */
    @Transactional
    public User processUserLogin(User user) {
        String userKey = user.getProvider() + ":" + user.getProviderId();

        // Try to find existing user by provider and provider ID
        Optional<User> existingUserOpt = userRepository.findByProviderAndProviderId(
            user.getProvider(),
            user.getProviderId()
        );

        if (existingUserOpt.isPresent()) {
            // User exists - update their information and last login time
            User existingUser = existingUserOpt.get();
            logger.info("Existing user logging in: {} ({})", user.getName(), userKey);

            existingUser.setName(user.getName());
            existingUser.setEmail(user.getEmail());
            existingUser.setAvatarUrl(user.getAvatarUrl());
            existingUser.setLastLoginAt(LocalDateTime.now());
            existingUser.setAttributes(user.getAttributes());  // Transient field, not persisted

            // Save updates to database
            return userRepository.save(existingUser);
        } else {
            // New user - save to database (ID auto-generated)
            logger.info("New user registering: {} ({})", user.getName(), userKey);

            // Note: ID is null here, will be auto-generated by database
            return userRepository.save(user);
        }
    }

    /**
     * Retrieves a user by provider and provider ID.
     *
     * @param provider The OAuth2 provider (github, google, etc.)
     * @param providerId The user's ID at that provider
     * @return Optional containing the user if found, empty otherwise
     */
    public Optional<User> getUserByProviderId(String provider, String providerId) {
        return userRepository.findByProviderAndProviderId(provider, providerId);
    }

    /**
     * Retrieves a user by email address.
     * Useful for account linking across providers.
     *
     * @param email The user's email address
     * @return Optional containing the user if found, empty otherwise
     */
    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    /**
     * Gets all registered users from the database.
     * Primarily for admin/debugging purposes.
     *
     * @return List of all users
     */
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    /**
     * Gets the total number of registered users from the database.
     *
     * @return User count
     */
    public long getUserCount() {
        return userRepository.count();
    }

    /**
     * Deletes a user from the database.
     * (For GDPR compliance - right to be forgotten)
     *
     * @param user The user to delete
     */
    @Transactional
    public void deleteUser(User user) {
        logger.info("Deleting user: {} ({}:{})", user.getName(), user.getProvider(), user.getProviderId());
        userRepository.delete(user);
    }

    /*
     * PRODUCTION CONSIDERATIONS:
     *
     * In a real application, you would:
     *
     * 1. DATABASE PERSISTENCE
     *    - Use JPA/Hibernate with a User entity
     *    - Store users in a relational database
     *    - Create proper indexes on provider + providerId
     *
     * 2. ACCOUNT LINKING
     *    - Allow users to link multiple OAuth2 providers to one account
     *    - Match users by email across providers
     *    - Provide UI for managing linked accounts
     *
     * 3. USER ROLES AND PERMISSIONS
     *    - Implement role-based access control (RBAC)
     *    - Store user authorities in the database
     *    - Return GrantedAuthority list in UserPrincipal
     *
     * 4. AUDIT TRAIL
     *    - Log all login attempts
     *    - Track authentication failures
     *    - Store IP addresses and device info
     *
     * 5. GDPR COMPLIANCE
     *    - Allow users to export their data
     *    - Provide account deletion functionality
     *    - Store minimal necessary information
     *
     * 6. TOKEN REFRESH
     *    - Store OAuth2 refresh tokens securely
     *    - Implement token refresh logic
     *    - Handle token expiration gracefully
     */
}
